<!DOCTYPE html>
<html>
<head>
	<title></title>
	<style>
		body {
			margin: 0;
			padding: 0;
		}
	</style>
	<script src="public/javascripts/jquery-1.11.1.min.js"></script>
	<script src="public/javascripts/sugar.min.js"></script>
	<script src="public/javascripts/pixi.dev.js"></script>
	<script src="public/javascripts/keyboard.js"></script>
</head>
<body>
<script type="text/javascript">
$(function() {
	var socket = new WebSocket('@@{Comms.stream()}');

	// Load them google fonts before starting...!
	WebFontConfig = {
		google: {
			families: [ 'Snippet', 'Arvo:700italic', 'Podkova:700' ]
		},

		active: function() {
		}
	};
	(function() {
		var wf = document.createElement('script');
		wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
				'://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
		wf.type = 'text/javascript';
		wf.async = 'true';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(wf, s);
	})();

	var TEXT_OFFSET_Y = 105;


	var getTextX = function(sprite,text) {
		text.updateTransform();
		var offset = -(text.width /2);
		return sprite.position.x + offset;
	};

	var log = function(message) {
		$('#thread').append("<div>"+message+"</div>");
	}
	// ----------------------- Receive Message --------------------
	var receiveMessage = function (event) {
		var parsedEvent = JSON.parse(event);
		// ----------------- talk message ------------------
		if (parsedEvent.action == "TALK") {
			var message = "<div>" +
					"<span style='color:white;font-weight:bold;background-color:#" + parsedEvent.playerColor + "'>" + parsedEvent.playerName + "</span>" +
					"<span>" + parsedEvent.playerMessage + "</span>" +
					"</div>"
			$('#thread').append(message);

			var player = players[parsedEvent.playerId];
			var bubbleObject = makeSpeechBubble(parsedEvent.playerMessage);
			if (player.speechBubble) {
				stage.removeChild(player.text);
				stage.removeChild(player.speechBubble);
			}
			player.speechBubble = bubbleObject.speechBubble;
			player.text = bubbleObject.text;
			setTimeout(function() {
				if (player.speechBubble) {
					player.speechBubble.opacity = 0.9;
				}
			},5000);
		}
		// ----------------- join message ------------------
		if (parsedEvent.action == "JOIN") {
			var message = "<div>" +
					"<span style='font-weight:bold;color:#" + parsedEvent.playerColor + "'>" + parsedEvent.playerName + "</span>" +
					"<span> joined.</span>" +
					"</div>";
			$("#thread").append(message);
		}
		if (! players.keys) {
			players = Object.extended(players);
			players.keys(function(key){players[key].seen = false});
		}
		parsedEvent.positions.each(function(player){
			var playerRecord = players[player.id];
			if (!playerRecord) {

				var texture = PIXI.Texture.fromImage("/public/images/"+player.icon);
				var sprite = new PIXI.Sprite(texture);
				sprite.anchor.x = 0.5;
				sprite.anchor.y = 0.5;

				// move the sprite to the center of the screen
				sprite.position.x = player.x;
				sprite.position.y = player.y;
				stage.addChild(sprite);

				var text = new PIXI.Text(player.name, {font: "15px Snippet", fill: "white", align: "center"});
				stage.addChild(text);
				text.position.x = getTextX(sprite,text);
				text.position.y = player.y + TEXT_OFFSET_Y;

				playerRecord = {
					id:player.id,
					sprite: sprite,
					nameBadge: text
				}
				players[player.id] = playerRecord;
			}
			playerRecord.sprite.position.x = player.x;
			playerRecord.sprite.position.y = player.y;
			playerRecord.nameBadge.position.x = getTextX(playerRecord.sprite,playerRecord.nameBadge);
			playerRecord.nameBadge.position.y = player.y + TEXT_OFFSET_Y;
			if (playerRecord.speechBubble) {
				var textStuff = playerRecord.text;
				textStuff.position.x = player.x - textStuff.width / 2;
				textStuff.position.y = player.y - 105 - textStuff.height / 2;
				playerRecord.speechBubble.position.x = textStuff.position.x - 10;
				playerRecord.speechBubble.position.y = textStuff.position.y - 22;
			}
			playerRecord.seen = true;
		});
		players.keys()
				.filter(function(key){ return !players[key].seen; })
				.each(function(key){
					var oldChild = players[key].sprite;
					if (stage.children.indexOf(oldChild) != -1) {
						console.log("removing sprite");
						stage.removeChild(players[key].sprite);
					} else {
						console.log("not a child....")
					}
					delete players[key];
				});
	};

	var id;
	var myName;

	var players = {};

	socket.onmessage = function (event) {
		receiveMessage(event.data);
	}

	$("#gobutton").click(sendit);

	$("#textForm").submit(function (e) {
		e.preventDefault();
		sendit();
	});

	$("#loginForm").submit(function(e) {
		e.preventDefault();
		doLogin();
	});

	$("#joinButton").click();

	var sendit = function () {
		var $textin = $("#textin");
		socket.send("id:" + id + ":TALK:" + $textin.val());
		$textin.val("");
	}

	var doLogin = function () {
		var userName = $("#userName").val().trim();
		if (userName != "") {
			myName = userName;
			$.ajax({
				type: "POST",
				url: '@@{Application.join()}',
				data: { userName: userName },
				dataType: 'json',
				success: function (data) {
					id = data.id;
					$("#preJoinUi").slideUp();
					$("#joinedUi").slideDown();
					socket.send("id:" + id + ":JOIN");
				},
				error: function (jqXHR, textStatus, errorThrown) {
					console.log("Error", jqXHR, textStatus, errorThrown);
				}
			});
		}
	};
	// create an new instance of a pixi stage
	var stage = new PIXI.Stage(0x66FF99);

	// create a renderer instance
	var renderer = PIXI.autoDetectRenderer(500, 500,$("#canvas")[0]);

//	// add the renderer view element to the DOM
//	document.body.appendChild(renderer.view);

	requestAnimFrame(animate);

	var backgroundTexture = new PIXI.Texture.fromImage("/public/images/background.jpg");
	var background = new PIXI.TilingSprite(backgroundTexture, 500, 500);
	background.position.x = 0;
	background.position.y = 0;
	background.tilePosition.x = 0;
	background.tilePosition.y = 0;

	stage.addChild(background);
	var speed = 2;

	function handleKeyboard(message) {
		if (!id) {
			return;
		}
		var playerRecord = players[id];
		if (!playerRecord) {
			return;
		}
		var sprite = playerRecord.sprite;
		var nameBadge = playerRecord.nameBadge;
		if (message.indexOf("up") != -1) {
			sprite.position.y -= speed;
		}
		if (message.indexOf("down") != -1) {
			sprite.position.y += speed;
		}
		if (message.indexOf("left") != -1) {
			sprite.position.x -= speed;
		}
		if (message.indexOf("right") != -1) {
			sprite.position.x += speed;
		}
		nameBadge.position.x = getTextX(sprite,nameBadge);
		nameBadge.position.y = sprite.position.y + TEXT_OFFSET_Y;
		if (lastX != sprite.position.x || lastY != sprite.position.y) {
			lastX = sprite.position.x;
			lastY = sprite.position.y;
			sendMove(lastX,lastY);
		}
	}

	function sendMove(xpos,ypos) {
		socket.send("id:" + id + ":MOVE:" + xpos + ":" + ypos);
	};

	function handleSpeechFadeouts() {
		if (!players.keys) {
			players = Object.extended(players);
		}
		players.keys().each(function(key){
			var player = players[key];
			var speechBubble = player.speechBubble;
			var text = player.text;
			if (speechBubble) {
				if (speechBubble.opacity && speechBubble.opacity < 1) {
					if (speechBubble.opacity < .0001) {
						stage.removeChild(text);
						stage.removeChild(speechBubble);
						delete player.speechBubble;
					} else {
						var newOpacity = speechBubble.opacity * 0.93;
						speechBubble.opacity = newOpacity;
						text.opatory = newOpacity;
					}
				}
			}
		});
	}

	function makeSpeechBubble(textMessage) {
		// TODO I don't like the way this is--we have to construct the text object twice
		var text = new PIXI.Text(textMessage, {font: "15px Snippet", fill: "white", align: "center", wordWrap:true, wordWrapWidth:214});
		text.position.x = 200 - text.width / 2;
		text.position.y = 150 + offsety - text.height /2;


		var graphics = new PIXI.Graphics();
//		graphics.moveTo(50,50);
		graphics.beginFill(0xefefef);
		graphics.lineStyle(3, 0xdddddd, 1);
		var offsety = -105;
		graphics.drawRoundedRect(0,15,text.width+20,11 + text.height,5);
		graphics.endFill();

		stage.addChild(graphics);

		text = new PIXI.Text(textMessage, {font: "15px Snippet", fill: "ccc", align: "center", wordWrap:true, wordWrapWidth:214});
		text.position.x = 200 - text.width / 2;
		text.position.y = 150 + offsety - text.height /2;

		log("text width is" + text.width);
		log("text height is" + text.height);
		stage.addChild(text);
		return {speechBubble:graphics,text:text};
	}


	var lastX = 0;
	var lastY = 0;

	function animate() {
		requestAnimFrame(animate);
		var message = KeyboardJS.activeKeys();
		handleKeyboard(message);
		handleSpeechFadeouts();
		// render the stage
		renderer.render(stage);
	}

});
</script>
<canvas style="height:500px;width:500px;" id="canvas"></canvas>
<div id="preJoinUi">
	<form id="loginForm">
		<label for="userName">Name: </label><input name="userName" id="userName" type="text"><button id="joinButton">Join</button>
	</form>
</div>
<div id="joinedUi" style="display:none;">
	<form id="textForm">
		<input id="textin" type="text" style="width:300px"/>
		<button id="gobutton">Go</button>
	</form>
</div>
<div id="thread"></div>

</body>
</html>